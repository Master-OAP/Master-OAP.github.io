---
title: "6.S081：实验"
date: 2023-07-10T20:08:56+08:00
categories: []
summary: '实验捏'
tags: ['/img/6.S081/6.S081.png']
# heroimage: '/img/6.S081/mit.png'
images: ['/img/6.S081/6.S081.png', '/img/6.S081/mit.png']
categories: ['OS', '6.S081']
draft: false
---
{{< simple-notice simple-notice-note >}}
1. 2023-7-10开始 2023-12-23搞定
2. 还需要一个好点的总结，保证对所有知识都融会贯通，加油吧
3. 搞完看一下jyy的课，常读常新
4. [lab代码](https://github.com/O-A-P/6.S081)
{{< /simple-notice >}}
# 1. Lab1
## 1.1 配置项目环境
照着[这个](https://pdos.csail.mit.edu/6.S081/2020/tools.html)或者[这个](https://zhuanlan.zhihu.com/p/343655412)搭建一遍就OK，此外要跑测试的话可能会找不到python环境，配置一下软链接就行，记住一定要用fetch再git checkout lab_name的方式建立，不要自己建立新的branch，一些文件可能会存在问题！！！
## 1.2 配置编码环境
项目是使用makefile进行组织编译的，采用交叉编译，如果直接用vscode打开则不能跳转函数，不大方便，可以看[jyy视频](https://www.bilibili.com/video/av638326614/?vd_source=71ee144274d993f1c946fc98badf272d)通过`bear`工具生成`compile_commands.json`文件，随后[配置插件](https://zhuanlan.zhihu.com/p/501901665)使之能够加载这个文件，从而可以保证函数跳转。但vscode用起来还是不舒服，配文件啥的很麻烦，我采用的方案是使用clion远程链接wsl（其实本地也能打开这个项目文件，但是解析compile_commands.json的时候由于路径是wsl路径所以会出问题，因此使用remote方案），首先`bear make qemu`编译完成后退出，生成compile_commands.json文件，clion选择打开即可，打开的时候要选择compilation database项目，如此就可以随便跳转了，其他可以参考一下这个使[clion支持makefile项目](http://www.langdebuqing.com/others%20notebook/%E4%BD%BFclion%E6%94%AF%E6%8C%81makefile%E9%A1%B9%E7%9B%AE.html)。
妈的现在发现clion连wsl写中文注释会出现代码高亮失效的情况，而且卡得一批，还是用vscode+clangd组合吧，参考[这个](https://github.com/Aneureka/xv6-riscv)，`注意.h文件有问题得自己手动搞`，.clang-format参考[这个老哥的](https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/#VSCode%E9%85%8D%E7%BD%AE)
## 1.3 系统调用
![syscall](/img/6.S081/syscall.png "all syscall")
## 1.4 sleep
使用系统调用int sleep(int)封装一下就行，最终还是使用汇编来调用kernel层中最基础的sys_sleep，注意特殊情况如的处理。另外还需要注意，C语言整个编译过程要保证定义只有一次，这里想用user/ulib.c中的atoi函数，导入ulib.c会造成重复编译，直接在文件里声明atoi函数即可。写完之后要在Makefile里加上对应的文件名。代码如下：
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int atoi(const char *s);

int main(int argc, char *argv[])
{
    if (argc <= 1)
    {
        fprintf(2, "sleep: please set up sleep time\n");
        exit(1);
    }
    if (argc > 2)
    {
        fprintf(2, "sleep: too many arguments\n");
        exit(1);
    }
    sleep(atoi(argv[1]));
    exit(0);
}
```
## 1.5 pingpong
要知道，pipe可以在进程间通信，随后只需要两个pipe，一个负责从父进程向子进程传输数据，一个负责从子进程向父进程传输数据，先写后读，关闭对应的pipe端即可。代码如下：
```c
#include "kernel/types.h"
#include "user/user.h" // fork

int main(int argc, char *argv[])
{
    char buffer[5];
    if (argc > 1)
    {
        fprintf(2, "pingpong: too many arguments");
    }
    int parent_to_child[2];
    int child_to_parent[2];
    // trans data from parent to child
    pipe(parent_to_child);
    // trans data from child to parent
    pipe(child_to_parent);

    if (fork() == 0)
    {
        // child process
        // close write end of parent to child;
        close(parent_to_child[1]);
        // close read en of child to parent;
        close(child_to_parent[0]);
        write(child_to_parent[1], "pong\n", 5);
        // close write end of child to parent
        close(child_to_parent[1]);
        read(parent_to_child[0], buffer, sizeof(buffer));
        // close read end of parent to child
        close(parent_to_child[1]);
        printf("%d: received ", getpid());
        write(1, buffer, 5);
    }
    else
    {
        // parent process
        // close read end of parent to child
        close(parent_to_child[0]);
        // close write end of child to parent
        close(child_to_parent[1]);
        write(parent_to_child[1], "ping\n", 5);
        // close write end of parent to child
        close(parent_to_child[1]);
        read(child_to_parent[0], buffer, sizeof(buffer));
        // close read end of child to parent
        close(child_to_parent[0]);
        printf("%d: received ", getpid());
        write(1, buffer, 5);
    }
    exit(0);
}
```
## 1.6 primes
首先还得看懂教程提示：从2-35依次送往pipe读端，然后循环创建进程处理每一次丢弃后的数据。此外，要时刻记住三件事：
- 把握数据的流向
- 关闭不用的pipe的所有的读端和写端，否则会阻塞
- 数据在pipe中是单向流动的
代码如下：
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

void prime(int read_pipe, int write_pipe, int divider)
{
    int num;
    while (read(read_pipe, &num, sizeof(int)) != 0)
    {
        if (num % divider != 0)
        {
            write(write_pipe, &num, sizeof(int));
        }
    }
    close(read_pipe);
    close(write_pipe);
    
    exit(0);
}

#define MAX 35

int main()
{
    int p[2];
    pipe(p);

    if (fork() == 0)
    {
        close(p[0]);
        // child process 0: write all number to pipe
        for (int i = 2; i <= MAX; i++)
        {
            write(p[1], &i, sizeof(int));
        }
        close(p[1]);
        exit(0);
    }

    int num;
    int read_pipe = p[0];
    int write_pipe;
    close(p[1]);

    while (read(read_pipe, &num, sizeof(int)) != 0)
    {
        int p_next[2];
        pipe(p_next);
        write_pipe = p_next[1];

        if (fork() == 0)
        {
            // child process
            printf("prime %d\n", num);
            // read data and send prime to the next pipe
            prime(read_pipe, write_pipe, num);
            close(read_pipe);
            close(write_pipe);
            close(p_next[0]);
            // close this process
            exit(0);
        }
        else
        {
            // father process
            close(read_pipe);
            close(write_pipe);
            read_pipe = p_next[0];
        }
    }
    // father: close read end
    close(read_pipe);
    wait(0);
    exit(0);
}
```
## 1.7 find
写一个find函数，真是踩了太多坑了，一开始写出来了，但是不清楚为什么需要按一下回车才能执行结果，苦苦debug了很久，gdb也有bug，明明在find.c的main打的断点，用一下ls居然也触发了，真是吃屎。最后灵感迸发，把while里面的if的判断条件换了个位置就可以不用按回车了。
解决思路也很简单，先判断是目录还是文件，是文件就对比，是目录就递归调用，这里需要注意：
- 有时候测试卡住了跑一下make clean就可以
- 注意./gdb_init里的端口设置，保证能够连接
- 注意端口占用，有时候会有程序不知不觉占用25000端口导致gdb不可用
- 注意函数的行为，如fstat、stat、strlen、strcpy、strcmp等函数的行为
- 一些边界情况也要写全，不要不写
- makefile和gdb等工具还是要学一下，不然一大堆事情
代码如下：
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

// recusively find file_name in path
// path is directory by default
void find(char* path, char* file_name)
{
    char buf[512], *p;
    int fd; // file descriptor
    struct stat st;
    struct dirent de;
    if ((fd = open(path, 0)) < 0)
    {
        fprintf(2, "find: cannot open %s\n", path);
        return;
    }
    if (fstat(fd, &st) < 0)
    {
        fprintf(2, "find: cannot open %s\n", path);
        close(fd);
        return;
    }
    if(st.type == T_FILE)
    {
        fprintf(2, "find: please enter directory path\n");
        close(fd);
        return;
    }
    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf)
    {
        printf("find: path too long\n");
        close(fd);
        return;
    }
    strcpy(buf, path);
    p = buf + strlen(buf);
    *p++ = '/';
    // read from directory，every time read a dirent
    while (read(fd, &de, sizeof(de)) == sizeof(de))
    {
        if((de.inum == 0) || (strcmp(de.name, ".") == 0) || (strcmp(de.name, "..") == 0))
            continue;
        memmove(p, de.name, DIRSIZ);
        p[DIRSIZ] = 0; // add end mark
        if(stat(buf, &st) < 0)
        {
            printf("ls: cannot stat %s\n", buf);
            continue;
        }
        if (st.type == T_DIR)
        {
            // if path is a directory, continue to recursion
            find(buf, file_name);
        }
        else 
        {
            // if path is a file, then compare it with file name
            if (strcmp(de.name, file_name) == 0)
            {
                fprintf(1, "%s\n", buf);
                continue;
            }
        }
    }
    close(fd);
    return;
    // exit(0);
}

int main(int argc, char *argv[])
{
    if (argc < 3) 
    {
        fprintf(2, "find: please enter enough arguments\n");
        exit(1);
    }
    if (argc > 3)
    {
        fprintf(2, "find: too many arguments\n");
        exit(1);
    }
    find(argv[1], argv[2]);
    exit(0);
}
```
## 1.8 xargs
xargs是拿到上一个指令的输出，并且按照一定的规则（-n）塞给下一个指定程序（作为xargs的参数），如：

![xargs](/img/6.S081/xargs.png "xargs示例")

注意获取数据是从标准输入获取，因为不知道大小只能获取一个字符，如果获取到了换行符则认为是一组参数，很简单，用到了一点K&R的读取技巧。随后使用fork和exec进行执行，非常简单，完整代码如下：
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/param.h"

int main(int argc, char *argv[])
{
    char *argv_real[MAXARG];
    char tmp = 0;
    char arg[MAXARG]; // store arg passed by pipe
    int index = 0;

    if (argc < 2)
    {
        fprintf(2, "xargs: more arguments required!");
    }
    if (argc > MAXARG - 1)
    {
        fprintf(2, "xargs: too many arguments!");
    }

    for (int i = 0; i < argc - 1; i++)
    {
        argv_real[i] = argv[i + 1];
    }

    while (read(0, &tmp, sizeof(tmp)) != 0)
    {
        if (index == MAXARG - 1)
        {
            fprintf(2, "xargs: argument is too long");
        }
        if (tmp != '\n')
        {
            arg[index++] = tmp;
        }
        else
        {
            arg[index] = '\0';
            index = 0;
            // fork and exec
            if (fork() == 0)
            {
                argv_real[argc - 1] = arg;
                exec(argv_real[0], argv_real);
                exit(0);
            }
            else
            {
                // wait for child process
                wait(0);
            }
        }
    }
    exit(0);
}
```
# 2. Lab2
## 2.1 sys_trace
设计一个sys_trace系统调用，这里有很多需要注意的地方，首先是执行流程：
1. 在user.h添加一个void trace(int)的函数原型，然后在usys.pl中添加entry("trace")，usys.pl会通过脚本生成一堆汇编代码(user/usys.S)，生成下面这段代码：
```c
.global trace
trace:
 li a7, SYS_trace
 ecall
 ret
```
作用就是声明一个全局的代码段，当trace函数被调用时，执行该程序，该程序将SYS_trace（一个由kernel/syscall.h中定义的宏）传入到a7中，随后执行ecall，ecall的含义比较复杂，暂且不知道，但一点是肯定的，它会带着数据执行syscall！

2. ecall则会整理数据后跳转到syscall函数(kernel/syscall.c)，根据SYS_trace决定执行数组中的对应的函数，在此例中则是sys_trace系统调用（kernel/sysproc.c）

3. 在sys_trace系统调用中采用argint函数获取trace函数传入的参数，并将其赋值给trace_mask（kernel/proc.h），系统调用执行完毕后返回syscall打印题目要求的输出。

执行流程有点麻烦，其中最让人疑惑的就是参数从trace传递到sys_trace，目前不知道用了什么手段，但应该是把数据存在某些地方。
具体来说要做的事情有：
1. 在user/user.h中添加trace函数的原型：
```c
int trace(int); // 返回值要和sys_trace保持一致，输入不用
```
2. 在kernel/syscall.h中添加宏定义，即系统调用的标号
```c
#define SYS_trace  22
```
3. 在user/usys.pl中添加entry，建立trace和SYS_trace的关联
```c
entry("trace");
```
4. 在kernel/sysproc.c中添加sys_trace函数，函数原型要与其他函数保持一致，便于syscall统一调用

```c
uint64 sys_trace(void)
{
  int mask;
  if (argint(0, &mask) < 0) // 这里不太明白从哪里读的
  {
    return -1;
  }
  // set trace mask
  struct proc *p = myproc();
  p->trace_mask = mask;

  return 0;
}
```
5. 在kernel/syscall.c的函数数组中添加`[SYS_trace] sys_trace`，并在前面加上`extern`声明，这是C的语法，指定下标元素的值；添加id与名字对应的数组：
```c
const char *syscall_name[] = {
    [SYS_fork] "fork",
    [SYS_exit] "exit",
    [SYS_wait] "wait",
    [SYS_pipe] "pipe",
    [SYS_read] "read",
    [SYS_kill] "kill",
    [SYS_exec] "exec",
    [SYS_fstat] "fstat",
    [SYS_chdir] "chdir",
    [SYS_dup] "dup",
    [SYS_getpid] "getpid",
    [SYS_sbrk] "sbrk",
    [SYS_sleep] "sleep",
    [SYS_uptime] "uptime",
    [SYS_open] "open",
    [SYS_write] "write",
    [SYS_mknod] "mknod",
    [SYS_unlink] "unlink",
    [SYS_link] "link",
    [SYS_mkdir] "mkdir",
    [SYS_close] "close",
    [SYS_trace] "trace",
};
```
6. 在kernel/proc.h中添加trace_mask来记录数据
```c
// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  int trace_mask;

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};
```
7. 在kernel/syscall.c中的syscall函数中添加行为，检测当前系统调用和开启trace的系统调用是否一致，如果一致则打印信息：
```c
void syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
  {
    p->trapframe->a0 = syscalls[num]();

    if ((p->trace_mask & (1 << num)) != 0)
    {
      // open trace
      printf("%d: syscall %s -> %d\n", p->pid, syscall_name[num], p->trapframe->a0);
    }
  }
  else
  {
    printf("%d %s: unknown sys call %d\n",
           p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```
8. 在user中添加trace.c文件来执行：
```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/param.h"

int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        fprintf(2, "trace: wrong number of arguments!\n");
        exit(1);
    }

    int mask = atoi(argv[1]);
    char *argv_real[MAXARG];

    trace(mask);

    for (int i = 0; i < argc - 2; i++)
    {
        argv_real[i] = argv[i + 2];
    }

    if (fork() == 0)
    {
        exec(argv_real[0], argv_real);
    }
    else
    {
        wait(0);
    }
    exit(0);
}
```
还有一些关于debug的部分比较重要，网友解释，主要是要了解gdb是通过file操作来读取最终生成的可执行文件或者说ELF（Executable and Linkable Format），后续的所有打断点都是基于ELF文件来的，有时候解释不了就没有办法打断点。
## 2.2 sys_sysinfo
妈的这个系统调用一定要叫sysinfo，不然会出错
1. 还是和上个实验一样增加一些前置定义
2. 主要目的是统计free memory和used process，那么第一步就是寻找free memory的数量，根据提示可以在kernel/kalloc.c中看到kalloc函数，里面有个kmem的结构体，freelist应该就是链表，存储所有空闲的pagesize的内存，指向的地方是空闲的4096大小的内存的首地址，那么后续就和普通链表操作一样，统计一共有多少page：
```c
// return free memory in bytes
uint64 get_free_memory(void)
{
  struct run *r;

  uint64 count = 0;
  acquire(&kmem.lock);
  r = kmem.freelist;
  while (r)
  {
    r = r->next;
    ++count;
  }
  release(&kmem.lock);
  return count * PGSIZE;
}
```
3. 下一步是找到已经使用的进程的数量，根据提示可以在kernel/proc.c中看到一个allocproc的函数，里面的行为正是从proc数组中获取状态，如果不是UNUSED那么就将其纳入统计，代码如下：
```c
// get processes whose state is not UNUSED
uint64 get_used_process(void)
{
  struct proc *p;
  uint64 count = 0;
  for (p = proc; p < &proc[NPROC]; p++)
  {
    acquire(&p->lock);
    if (p->state != UNUSED)
    {
      ++count;
    }
    release(&p->lock);
  }
  return count;
}
```
4. 写sys_sysinfo系统调用，这里面要尤其注意，获取的参数是地址，但这个地址实际上是用户态的栈空间中的地址，内核态时似乎不允许直接访问，这里需要先获取用户空间中sysinfo结构体的地址，再构建一个临时的sysinfo对象存储数据，再使用copyout函数从内核空间将数据复制到用户空间，代码如下：
```c
extern uint64 get_free_memory(void);
extern uint64 get_used_process(void);

uint64 sys_sysinfo(void)
{
  uint64 info;
  struct sysinfo p_sysinfo;
  
  struct proc *p = myproc();
  // 这里获取的info是用户空间的虚拟地址，直接读写根本就不行，因为此时在内核空间，很容易搞崩
  if (argaddr(0, &info) < 0)
  {
    return -1;
  }

  p_sysinfo.freemem = get_free_memory();
  p_sysinfo.nproc = get_used_process();
  // pagetable就是用户空间的数据，info则是虚拟目标地址，第三个则是源地址（内核空间），第四个就是需要复制的字节数量！
  if (copyout(p->pagetable, info, (char *)&p_sysinfo, sizeof(p_sysinfo)) < 0)
  {
    return -1;
  }
  return 0;
}
```
这里一定一定要注意，用户空间和内核空间的地址不是一样的，在内核态访问用户空间的地址会直接把内核搞崩溃！

# 3. Lab3
## 3.1 vmprint
实现一个vmprint的函数，遍历三层page_table树
1. 在kernel/vm.c中增加vmprint函数，首先打印该地址，随后遍历打印三层
```c
void vmprint(pagetable_t pagetable)
{
  printf("page table %p\n", pagetable);
  vmprint_recursively(pagetable, 1);
}
```
2. 遍历函数实现，本质上就是循环加遍历，CS106B有用的，抄一下freewalk函数就OK
```c
void vmprint_recursively(pagetable_t pagetable, int depth)
{
  for (int i = 0; i < 512; i++)
  {
    pte_t pte = pagetable[i];
    if (pte & PTE_V)
    {
      for (int j = 0; j < depth; j++)
      {
        if (j == 0)
        {
          printf("..");
        }
        else
        {
          printf(" ..");
        }
      }
      printf("%d: pte %p pa %p\n", i, pte, PTE2PA(pte));
      if ((pte & (PTE_R | PTE_W | PTE_X)) == 0)
      {
        vmprint_recursively((pagetable_t)PTE2PA(pte), depth + 1);
      }
    }
  }
}
```
3. 在kernel/defs.h中增加vmprint声明，在exec.c/exec中调用
```c
if (p->pid == 1)
  vmprint(p->pagetable);
```
这个实验倒是很简单，主要思路在freewalk函数里就有。
## 3.2 A kernel page table per process
其实这个实验是和下一个实验进行配合，对内核进行一点魔改，自始至终xv6都是通过SATP寄存器存储pagetable，进而对虚拟内存进行寻址找出真正的地址，在内核态SATP存储kernel pagetable而在用户态存储每个进程的pagetable即user pagetable，也就是说内核有pagetable，进程也有pagetable。这种情况就会造成用户态的地址在进入内核态后没用，因此这部分实验和后面的一个实验就是让每个进程都有一份kernel pagetable，进入内核态时不再使用全局的kernel pagetable，而是使用自己的，来达到让每个进程都能够便捷的使用自己的虚拟内存。

内核也是C程序，只不过是用来管理其他程序的C程序，一方面提供一些系统调用的接口，来使得其他程序能够便捷地与硬件沟通，另一方面还要管理其他程序的生命周期，为程序分配进程，回收进程。在分配方面，exec程序很重要，这个程序读取并检查可执行文件了ELF头，将程序加载进内存替换当前的进程的数据

1. 在kernel/proc.h中的proc结构体中增加字段kernel_pagetable，用来映射内核
```c
// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  pagetable_t kernel_pagetable;// lab 3
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};
```
2. 对于每个进程都需要一份kernel pagetable，因此需要一个函数来执行和kvminit函数相似的功能，本质上这就是对同一份物理地址进行多次映射，也就是说有多份虚拟地址指向同一份物理地址：
```c
pagetable_t get_kpt()
{
  pagetable_t kpt = (pagetable_t) kalloc();
  if (kpt == 0) {
    return 0;
  }
  memset(kpt, 0, PGSIZE);
  ukvmmap(kpt, UART0, UART0, PGSIZE, PTE_R | PTE_W);
  ukvmmap(kpt, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
  ukvmmap(kpt, CLINT, CLINT, 0x10000, PTE_R | PTE_W);
  ukvmmap(kpt, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
  ukvmmap(kpt, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
  ukvmmap(kpt, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
  ukvmmap(kpt, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
  return kpt;
}
```
3. 有了函数之后还需要在kernel/proc.c中的allocproc函数中进行调用，这个函数负责找出未使用的进程并返回，并且对这个进程struct来进行一些初始化（这玩意应该就是进程控制块），包括初始化kernel pagetable。
```c
static struct proc*
allocproc(void)
{
...
    // An empty user page table.
    p->pagetable = proc_pagetable(p);
    if(p->pagetable == 0){
      freeproc(p);
      release(&p->lock);
      return 0;
    }
    
    // 这里就相当于初始化了
    p->kernel_pagetable = get_kpt();
    if (p->kernel_pagetable == 0)
    {
      freeproc(p);
      release(&p->lock);
      return 0;
    }
...
}
```
4. 在kernel/proc.c:procinit函数中会负责映射全局的kernel pagetable中的针对每个进程的kstack，因此在进程的kernel pagetable中也至少要映射自己，同样需要一个函数来实现这个过程
// map kernel pagetable per process with pa
void ukvmmap(pagetable_t kpt, uint64 va, uint64 pa, uint64 sz, int perm)
{
  if (mappages(kpt, va, sz, pa, perm) != 0)
    panic("ukvmmap");
}
5. 此时还需要在kernel/proc.c:allocproc中调用这个函数，调用之前要保证先有物理内存
```c
static struct proc*
allocproc(void)
{
...
    // 这里就相当于初始化了
    p->kernel_pagetable = get_kpt();
    if (p->kernel_pagetable == 0)
    {
      freeproc(p);
      release(&p->lock);
      return 0;
    }
    // 同时也整了块内存来放kstack，这个kstack实际上是自己的
    char *pa = kalloc();
    if (pa == 0)
      panic("allocproc: kalloc");
    uint64 va = KSTACK((int)(p - proc));
    ukvmmap(p->kernel_pagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
    // 这个时候p->kstack指的就是kpt中的地址了
    p->kstack = va;
...
}
```
6. 现在初始化这个kernel pagetable已经完成了，但还需要在合适的地方使用这个东西（SATP寄存器），需要在kernel/proc.c:scheduler函数中对其进行调用，同时，如果没有进程被使用那么就可以直接调用全局的内核页表
```c
void
scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();
  
  c->proc = 0;
  for(;;){
    // Avoid deadlock by ensuring that devices can interrupt.
    intr_on();
    
    int found = 0;
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        // Switch to chosen process.  It is the process's job
        // to release its lock and then reacquire it
        // before jumping back to us.
        p->state = RUNNING;
        c->proc = p;
        w_satp(MAKE_SATP(p->kernel_pagetable));
        sfence_vma();
        swtch(&c->context, &p->context);

        // Process is done running for now.
        // It should have changed its p->state before coming back.
        c->proc = 0;

        found = 1;
      }
      release(&p->lock);
    }
#if !defined (LAB_FS)
    if(found == 0) {
      intr_on();
      w_satp(MAKE_SATP(kernel_pagetable));
      sfence_vma();
      asm volatile("wfi");
    }
#else
    ;
#endif
  }
}
```
7. 有了初始化，有了使用，下一个很自然的想法就是应该释放掉，毕竟内存是通过alloc来的，在free之前可以看看初始化的时候想想有哪些需要free的：
  1. 初始化的时候申请了一页kstack，那么这个需要被free掉
  2. 进程的内核页表本身用了一些空间来存储多级页表（在walk的时候分配的）
因此需要free以上这些东西，free kstack内存是很简单的，但是多级页表很麻烦，且不能free掉最终的物理内存，因为有其他的进程还在使用，所以需要一个函数来执行这个过程，实现需要参考freewalk函数，但切记不能free掉最终的物理内存。这里要注意，最后一级页表的RWX位肯定有一个为1，因此可以通过该种手段来判断是不是最后一级页表。（但感觉freewalk也是这么做的，感觉能直接用freewalk）
```c
void proc_freekpt(pagetable_t kpt)
{
  // kpt中有什么需要被free的？
  // 无非是之前map的pa，但pa又不是freelist管理的，因此没有必要去清除
  for (int i = 0; i < 512; i++)
  {
    pte_t pte = kpt[i];
    // 该pte是有效的，可以被访问
    if (pte & PTE_V)
    {
      kpt[i] = 0;
      // 这代表当前页表项b
      if ((pte & (PTE_R | PTE_W | PTE_X)) == 0)
      {
        uint64 child = PTE2PA(pte);
        proc_freekpt((pagetable_t)child);
      }
    }
  }
  kfree((void *)kpt);
}
```
因此最后只需要在freeproc函数中增加两部分即可
```c
static void
freeproc(struct proc *p)
{
  if(p->trapframe)
    kfree((void*)p->trapframe);
  p->trapframe = 0;
  // 删除kernel stack
  if (p->kstack)
  {
    pte_t *pte = walk(p->kernel_pagetable, p->kstack, 0);
    if (pte == 0)
      panic("freeproc: kstack");
    kfree((void *)PTE2PA(*pte));
  }
  if(p->pagetable)
    proc_freepagetable(p->pagetable, p->sz);
  // 删除kernel pagetable
  if (p->kernel_pagetable)
    proc_freekpt(p->kernel_pagetable);
  p->pagetable = 0;
  p->sz = 0;
  p->pid = 0;
  p->parent = 0;
  p->name[0] = 0;
  p->chan = 0;
  p->killed = 0;
  p->xstate = 0;
  p->state = UNUSED;
}
```
8. 实际上还有最后一个地方需要更改，那就是kvmpa函数，这里想办法让它使用process的页表
```c
uint64
kvmpa(uint64 va)
{
  uint64 off = va % PGSIZE;
  pte_t *pte;
  uint64 pa;
  
  pte = walk(myproc()->kernel_pagetable, va, 0);
  if(pte == 0)
    panic("kvmpa");
  if((*pte & PTE_V) == 0)
    panic("kvmpa");
  pa = PTE2PA(*pte);
  return pa+off;
}
```
## 3.3 Simplify copyin/copyinstr
3.2和3.2是搭配起来的，上面已经想办法让每个process都有自己的kernel pagetable，但这玩意没啥用，想要它真正起作用来达到在内核态时直接可以用虚拟地址就得想办法把每个process的pagetable映射到其kernel pagetable上，比上一个实验简单。这里需要做到的事情只有两件：
1. 把pagetable映射到kernel pagetable，根据hints可以知道可以在不超过PLIC(0xc000000)的地方映射pagetable，毕竟虚拟内存从0开始，参考uvmcopy函数的实现，魔改一个自己的函数就行，注意这里需要install ptes而不是去mappage，同时要记住清除标志位。
```c
void
uvmkptcopy(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz)
{
  pte_t *pte_from, *pte_to;
  uint64 a, pa;
  uint flags;

  if (newsz < oldsz)
    return;

  oldsz = PGROUNDUP(oldsz);
  for (a = oldsz; a < newsz; a += PGSIZE)
  {
    if ((pte_from = walk(pagetable, a, 0)) == 0)
      panic("u2kvmcopy: pte should exist");
    if ((pte_to = walk(kpagetable, a, 1)) == 0)
      panic("u2kvmcopy: walk fails");
    pa = PTE2PA(*pte_from);
    // 清除PTE_U的标记位
    flags = (PTE_FLAGS(*pte_from) & (~PTE_U));
    *pte_to = PA2PTE(pa) | flags;
  }
}
```

2. 在正确的地方调用这个函数，什么是正确的地方，就是pagetable改变的地方，根据提示共有四处：exec()、fork()、sbrk()、userinit()
  1. exec()
```c
int
exec(char *path, char **argv)
{
...
    sp = sz;
    stackbase = sp - PGSIZE;
    
    // 复制
    uvmkptcopy(pagetable, p->kernel_pagetable, 0, sz);
...
}
```
  2. fork()
```c
int
fork(void)
{
...
    uvmkptcopy(np->pagetable, np->kernel_pagetable, 0, np->sz);
    
    safestrcpy(np->name, p->name, sizeof(p->name));
...
}    
```
  3. sbrk()，这里要注意这个是个系统调用，真正需要添加的地方在growproc函数中
```c
int
growproc(int n)
{
  uint sz;
  struct proc *p = myproc();

  sz = p->sz;
  if(n > 0){
    if (PGROUNDUP(sz + n) >= PLIC)
      return -1;
    if((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
      return -1;
    }
    // 添加复制函数
    uvmkptcopy(p->pagetable, p->kernel_pagetable, sz-n, sz);
  } else if(n < 0){
    sz = uvmdealloc(p->pagetable, sz, sz + n);
  }
  p->sz = sz;
  return 0;
}
```
  4. userinit()
```c
// Set up first user process.
void
userinit(void)
{
  struct proc *p;

  p = allocproc();
  initproc = p;
  
  // allocate one user page and copy init's instructions
  // and data into it.
  uvminit(p->pagetable, initcode, sizeof(initcode));
  p->sz = PGSIZE;
  uvmkptcopy(p->pagetable, p->kernel_pagetable, 0, p->sz);

  // prepare for the very first "return" from kernel to user.
  p->trapframe->epc = 0;      // user program counter
  p->trapframe->sp = PGSIZE;  // user stack pointer

  safestrcpy(p->name, "initcode", sizeof(p->name));
  p->cwd = namei("/");

  p->state = RUNNABLE;

  release(&p->lock);
}
```
## 3.4 总结
这个实验妈的真难，part2基本不是人能想得到的，虽然基本的思路是有......

这里必须认识到所谓虚拟内存其实是假的，最开始只有freelist上可以被使用的内存，内核也得自己构建一块块内存，从0x0到0x88000000（PHYSTOP）都需要被映射，只不过0x0到0x80000000（KERNELBASE）是被映射到实际的物理设备的（可以先这样子想），后面的0x80000000到end都是被映射到数据和代码，end到PHYSTOP才是真正可以被内核和进程使用的内存，且是以页为单位被使用：

![kmemmap](/img/6.S081/kmemmap.png "内核映射")

在全局kernel pagetable被初始化的时候trampoline和kstack都映射到free memory里面（书上图也画错了）。因此可以知道真正的程序都是运行在一块一块的页内存中的，外部通过pagetable/kernel pagetable将其组织起来，于是就有了一大块从零开始的、连续的虚拟内存的假象。下面这个图PHYSTOP错的，是0x88000000
但在这一过程中，除了程序所必须的物理内存，实际上pagetable也是被存储在内存中的（walk函数），只不过这个内存并不被程序实际使用，而是用来存储映射关系（第二级和第三级页表都是如此）。

![pagetable](/img/6.S081/pagetable.png "多级页表")

其实这其中最为关键的地方是在exec函数里，加载elf文件，并用新程序覆盖原来的旧程序，最后应该还调整了PC让新程序被执行，妙啊。

![userspace](/img/6.S081/userspace.png "用户进程地址空间")
# 4. Lab4
## 4.1 前置知识
1. .ld文件实际上是编译阶段要使用的，在这里会定义程序的代码段、数据段等需要存放的位置，并将一定的符号给暴露出去，例如_trampoline
2. _entry文件是设置了很多块栈（RISC-V的栈是从上往下增长的），针对每一块CPU都设置了一页的栈，这个CPU栈的主要作用是处理内核模式下的中断和异常，这些堆栈是由start.c中初始化来的，与CPU数量一致。与kstack不同，kstack（内核栈）是用于处理进程在内核模式下的函数调用、中断和异常（即trap），数量与进程数量保持一致。因为在处理这些东西的时候仍然可能被中断，除了保存寄存器以外，也需要栈来保存函数调用的数据
3. caller寄存器和callee寄存器：caller寄存器一般用于保存返回地址的，用于恢复原有的调用者的正常运行；callee寄存器一般用于保存函数返回值，用于给调用者使用（如果返回值过大那有可能保存的是地址）
## 4.2 RISC-V assembly
1. Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

这里主要理解两张图：

![callingConvention](/img/6.S081/callingConvention.png "RISC-V calling convention")

![callingStack](/img/6.S081/callingStack.png "stack frame")

在代码中printf函数将控制序列放到a0中，将a1，a2分别存放两个参数，这与上表18.2基本一致，另外还需要了解一点栈帧的基本知识：RISC-V栈从上至下增长，且为小端（意味着返回的地址是最低有效位的地址），fp是该栈帧的基地址，sp的栈的栈顶地址，fp到sp之间即为一个栈帧，栈帧内首先存放返回地址，再一个就是上一个fp，用于找到上一个栈帧的位置（最终目的还是定位上一个栈帧的return address），再下来就是保存一些寄存器的值用作参数，最后为保存局部变量。

于是可以回答上述问题：1.  a0 a1 a2, a2 contains 13

2. Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)

这里倒没什么好讲的，主要是函数调用被编译器直接优化了。

因此：2.  Acctually compiler inline it and pre-calculate it out

3. At what address is the function printf located?

  在汇编代码里也有提示：
```c
30: 00000097             auipc ra,0x0 #此时ra内存的就是pc=0x30
34: 600080e7             jalr  1536(ra) # 630
```
其中0x630就是printf函数的地址，将立即数1536与ra内的值相加即得到了跳转的目标地址，在此之前ra内的地址就是pc的地址，而pc地址是0x30，加上1536则得出目标地址为1584（0x630）。

因此：3.  630

4. What value is in the register ra just after the jalr to printf in main?

jalr是跳转指令，以上面第二行为例，首先将ra内容加上1536作为目标跳转地址，随后jalr会将ra的值设置为当前PC+4，用于返回函数后恢复正常运行。

因此：4.  the address of current instruction plus 4

5. ...

{{< notice notice-info >}}
Run the following code.<br>
```c
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
```
What is the output? Here's an ASCII table that maps bytes to characters.The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?
{{< /notice >}}

57616的16进制为0xE110，%s则代表要读取的是字符串，因此默认小端读取，在ASCII码表中，0x72代表r，0x6c代表l，0x64代表d。因此可以得到最终输出。如果是大端的话则需要改变为0x726c640000000000，因为是64位的且要保证最后一位为停止符。57616我认为不需要变化，因为只要是正确读取正确输出那就没有问题。

因此：5.  HE110 World    0x726c640000000000    no, i don't need to

6. ...

{{< notice notice-info >}}
In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?
```c
printf("x=%d y=%d", 3);
```
{{< /notice >}}
阅读的printf汇编代码可以知道，会从a0读取输出格式，从a1-a7读取其他参数，那么在此处a1为3，y后面的值应该是a2的数据，在此情况下应该是个随机数。

因此：6. a random number in register a2
## 4.3 Backtrace
Backtrace要求实现一个函数来打印从顶至下打印栈帧，还算比较简单，知道kstack是做什么用的（上面有），kstack是从上至下增长，stack frame长什么样（上面有）即可。
1. 首先在kernel/printf.c中定义函数backtrace：
```c
void backtrace(void)
{
}
```
2. 在kernel/defs.h中增加函数声明
3. kernel/riscv.h中增加以下函数用于读取寄存器fp（frame pointer），C语言里写汇编，够骚
```c
static inline uint64
r_fp()
{
  uint64 x;
  asm volatile("mv %0, s0"
               : "=r"(x));
  return x;
}
```
4. 完善backtrace定义
```c
void backtrace(void)
{
  // current fp, fp contains the top fp address
  uint64 fp = r_fp();
  while(fp != PGROUNDUP(fp))
  {
    printf("%p\n",*((uint64*)(fp - 8)));
    fp = *((uint64 *)(fp - 16));
  }
}
```
5. bbtest一下可以正常输出结果
```bash
$ bttest
0x0000000080002ccc
0x0000000080002ba6
0x0000000080002890
```
并可以使用addr2line来根据地址逆向查找对应源文件位置
```bash
❯ addr2line -e kernel/kernel 0x0000000080002ccc 0x0000000080002ba6 0x0000000080002890
/home/zhangzihao/xv6-labs-2020/kernel/sysproc.c:62
/home/zhangzihao/xv6-labs-2020/kernel/syscall.c:140
/home/zhangzihao/xv6-labs-2020/kernel/trap.c:76
```
这里补充一下：
addr2line是一个用于逆向查找程序地址对应源代码位置的工具。它是GNU binutils工具集的一部分，可用于解析程序的地址并将其映射到源代码的行号和文件名。它常用于调试和错误排查过程中，特别是在崩溃和错误报告的分析中。通过使用addr2line，可以将程序计数器（Program Counter，PC）或地址作为输入，然后获取与该地址相关联的源代码位置信息。

6. 将backtrace加到panic函数里！
7. 小结

这个实验很简单，fp最后会回到进程对应的kstack的底部（也是地址最高点因此要PGROUNDUP），%p是带0x的地址打印，fp是栈帧的底部，但是从栈帧读取数据还是正常升序读取，因此要使用fp-8找到return address的位置，fp-16则是要找到上一个栈帧的地址。

这里唯一需要注意的是地址与数字的加减，要记住地址的运算出来的永远是地址单元的数量，这个地址单元是根据类型而定的，而非一个字节！

## 4.4 Alarm
实验要求很简单，完成两个系统调用，组合之下能够完成类似单片机设置定时中断的功能，实现思路很简单，跟着hint做就行，比page table简单1w倍。
1. 在Makefile中增加alarmtest.c
```makefile
UPROGS=\
...
    $U/_alarmtest\
```
2. user/user.h中增加两个新的系统调用
```c
int sigalarm(int ticks, void (*handler)());
int sigreturn(void);
```
3. user/usys.pl中增加系统调用对应的entry
```c
entry("sigalarm");
entry("sigreturn");
```
4. 随便挑一个内核文件增加对应的系统调用，sigalarm负责获取参数并将其记录于proc结构体里，此时sigreturn只用return 0即可，此外记得在proc.h中增加proc结构体中的字段ticks和handler
```c
uint64
sys_sigalarm(void)
{
  struct proc* p = myproc();
  // get interval and handler, store it to proc struct
  argint(0, &p->ticks);
  argaddr(1, &p->handler);
  return 0;
}
uint64
sys_sigreturn(void)
{
  return 0;
}
```
5. 在syscall.c中增加对应的外部引用和标号，在此不再赘述
6. trap.c/usertrap中增加如下语句，从而保证能够在系统时钟中断trap返回时直接去handler函数执行
```c
if(which_dev == 2)
{
  // the alarm is set
  if (p->ticks != 0)
  {
    p->ticks_to_last++;
    if (p->ticks_to_last == p->ticks)
    {
      // let user app invoke handler
      p->trapframe->epc = p->handler;
    }
  }
  yield();
}
```
至此基本完成了test0。
7. test1和2主要的目的是恢复时钟中断trap返回时的状态，首先需要在中断trap时保存对应状态，这里我偷懒直接用trapframe结构体保存了一下
```c
---
kernel/proc.h中proc中增加的字段
int ticks;
int ticks_to_last;
uint64 handler;
struct trapframe trapframe_for_sig;
---
kernel/trap.c中usertrap中的函数
// give up the CPU if this is a timer interrupt.
if(which_dev == 2)
{
  // the alarm is set
  if (p->ticks != 0)
  {
    p->ticks_to_last++;
    if (p->ticks_to_last == p->ticks)
    {
      // store the state
      p->trapframe_for_sig = *p->trapframe;

      // let user app invoke handler
      p->trapframe->epc = p->handler;
    }
  }
  yield();
}
```
8. 另外还需要在sigreturn中恢复状态
```c
uint64
sys_sigreturn(void)
{
  struct proc* p = myproc();
  *p->trapframe = p->trapframe_for_sig;
// 这里不用+4的原因是该次trap是时钟中断trap，而非syscall
//  p->trapframe->epc += 4;
  p->ticks_to_last = 0;
  return 0;
}
```
9. 小结：
    1. 设定定时函数时的流程为
        1. syscall
        2. （syscall）trap
    2. 定时函数被调用的流程为
        1. 定时器中断
        2. （定时器）trap
        3. usertrap中判断是否达到了设定时间，保存当前trapframe并通过修改trapframe中的epc来设置trap返回后的跳转
        4. trap返回根据设定的epc设置pc，从而实现跳转效果
    3. 定时函数返回流程为
        1. 定时器函数内执行sigreturn系统调用
        2. trap
        3. sigreturn内恢复现场并恢复trapframe！

这个实验很简单，但很好的展示了如何设定定时函数，最后的返回更是精妙，代码量不多，但能够很好地完成任务，good！
# 5. Lab5
## 5.1 前置知识
这个实验要做的是完成lazy allocation，还是虚拟内存相关的实验，copy-on-write，paging from disk也是一样。做这个实验之前还是要知道PTE的一些flag所代表的含义
## 5.2 Eliminate allocation from sbrk()
只是lazy allocation的前置，比较简单，课上也有演示，只需要在sbrk分配内存时不真正分配，只是记录需要增加的大小
```c
uint64
sys_sbrk(void)
{
...
  myproc()->sz = myproc()->sz + n;
//  if(growproc(n) < 0)
//    return -1;
  return addr;
}
```

最终按照测试打印如下：
```bash
$ echo hi
usertrap(): unexpected scause 0x000000000000000f pid=3
            sepc=0x00000000000012ac stval=0x0000000000004008
panic: uvmunmap: not mapped
```

可以简单分析一下：

usertrap的报错是unexpected scause 0xf，实际上是因为用户程序中的指令访问了不能访问的内存，在usertrap中没有对应处理的程序，pid=3是因为第一个process是init，第二个是shell，第三个就是echo hi了（先fork再exec），`sepc记录的是出错前的用户pc指令，stval是出错时的虚拟地址`

panic则是因为发生错误后需要清理内存，但是此时根据sz清理的内存实际上没有被map，因此会出错。
## 5.3 Lazy allocation和Lazytests and Usertests
这两部分情况比较特殊，可以一起做了

首先仔细分析一下，如果sbrk时不分配内存，只是记录sz的大小，此时如果进程访问未被分配的内存就会发生page fault，由trap过程中的usertrap进行处理，按照题目hints可以知道此时scause是13或15，此时需要对错误进行处理：
1. 获取发生错误时的虚拟地址
2. 申请物理内存
3. 将虚拟地址和物理内存映射起来

具体为usertrap函数中：
```c
else if (r_scause() == 13 || r_scause() == 15){
  // page fault handler
  uint64 va = r_stval();
  if (va > myproc()->sz || va < PGROUNDDOWN(myproc()->trapframe->sp)){
    p->killed = 1;
  } else {
    char* pa = kalloc();
    if (pa == 0) {
      p->killed = 1;
    } else {
      memset(pa, 0, PGSIZE);
      va = PGROUNDDOWN(va);
      if(mappages(myproc()->pagetable, va, PGSIZE, (uint64)pa, PTE_W|PTE_X|PTE_R|PTE_U) != 0){
        kfree(pa);
        p->killed=1;
        exit(-1);
      }
    }
  }
}
```

这里需要注意的是第四行如果内存读取到了超出最大地址和用户虚拟地址以下时是真的发生了page fault，此时需要杀掉进程，并且要处理申请不到内存和map出错的情况。

此外在sys_sbrk函数中还需要对增加后的地址大于MAXVA或者小于0时进行处理，并且除了lazy allocation之外，在减少内存时需要立刻减少，这里直接参照growproc来写就OK
```c
uint64
sys_sbrk(void)
{
  int addr;
  int n;

  if(argint(0, &n) < 0)
    return -1;
  addr = myproc()->sz;
  if (myproc()->sz + n >= MAXVA || myproc()->sz + n <= 0)
  {
    return addr;
  }
  myproc()->sz = myproc()->sz + n;

  if (n < 0){
    uvmdealloc(myproc()->pagetable, addr, myproc()->sz);
  }

  return addr;
}
```
除了上述的正常trap情况，如果在内核态时使用copyin和copyout函数，也同样需要进行类似usertrap的处理，因为此时不会有usertrap来正常处理page fault的情况，主要还是修改walkaddr函数，删除原有pte为0和valid flag为0的情况，增加如下处理
```c
if (pte == 0 || (*pte & PTE_V) == 0) {
  struct proc *p = myproc();
  if(va >= p->sz || va < PGROUNDDOWN(p->trapframe->sp)) return 0;

  pa = (uint64)kalloc();
  if (pa == 0) return 0;

  if (mappages(p->pagetable, va, PGSIZE, pa, PTE_W|PTE_R|PTE_U|PTE_X) != 0) {
    kfree((void*)pa);
    return 0;
  }
  return pa;
}
```
最后，取消掉panic的地方即可（uvmcopy和uvmunmap）

这个实验还有一个值得注意的地方是sh、fork和exec指令，其实sbrk是由sh中的malloc调用来执行的，目前还不是很了解这三者作用的细节，不过CSAPP好像有个shell实验可以试试看。
# 6. Lab6
{{< notice notice-tip >}}
其实这个实验应该和Lab5的lazy allocation一起做了的，效率应该是比较高的
{{< /notice >}}
## 6.1 问题引入
fork时会将内存复制一遍到新的进程地址空间，但实际上有时候fork后面马上跟了一个exec，这就导致之前的复制完全是没有意义的，另一方面，其实需要更改的可能只有一小部分数据，那按理来说只需要保证其他数据在真实的物理内存中只有一份，而需要更改数据存在两份（父子进程各自持有），在该种情况下，只需要更改映射就OK了

所以COW fork需要完成的主要功能就是延迟分配和复制物理内存直到真的需要，主要任务有以下几个：
1. 为子进程创建pagetable，但这个pagetable的所有pte都指向父进程的实际物理内存，即存在相同的映射
2. 将父子进程的所有PTE的flag都标记为不可写，当任何一个进程试图写的时候则会触发page fault，此时由trap来处理page faul：分配物理内存，复制新页面，更新该进程的PTE

根据提示有以下几步：
1. 更改uvmcopy在子进程的地址空间映射父进程的物理内存，并清除PTE的可写标志位
2. 更改usertrap来识别page fault（类似lazy allocation），分配新的物理内存，并从共享内存中copy对应数据，将其安装到page table中，更改PTE的可写标志位
3. 保证物理内存在没有映射后会被正确地释放，例如通过引用计数来统计引用每个物理页面的数量，kalloc分配时设置为1，fork存在共享时增加引用计数，进程从其页表中删除页面时减少引用技术。只有引用计数为0时才能够kfree掉。可以通过一个数组来追踪每个页面引用计数的数量，通过页面的物理地址/4096来索引空闲列表中的每一个物理页面（所以有多少页面呢？）
4. 更改copyout来处理COW导致的page fault
5. 如果COW page fault发生后没有空闲内存了，则直接杀掉进程（尝试写数据的进程），引用计数减1
## 6.2 Copy on Write
1. fork步骤中，最重要的是步骤是从父进程赋值进程到子进程，其中最为重要的是uvmcopy函数，这一步需要更改的如下：
```c
int
uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
{
  pte_t *pte;
  uint64 pa, i;
  uint flags;
  // char *mem;

  for(i = 0; i < sz; i += PGSIZE){
    if((pte = walk(old, i, 0)) == 0)
      panic("uvmcopy: pte should exist");
    if((*pte & PTE_V) == 0)
      panic("uvmcopy: page not present");
    pa = PTE2PA(*pte);
    // record at RSW to tell whether a PTE is COW mapping
    // modify old pagetable's pte to clear PET_W in parent and child
    *pte &= ~PTE_W;
    *pte |= PTE_COW;
    flags = PTE_FLAGS(*pte);

    // in cow fork, we don't allocate memory for copying
    if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0){
      // and don't free any memory
      goto err;
    }
    // increase the reference count
    acquire(&(mem_ref[pa/PGSIZE].lock));
    mem_ref[(uint64)pa/PGSIZE].cnt++;
    release(&(mem_ref[pa/PGSIZE].lock));
  }
  return 0;

 err:
  uvmunmap(new, 0, i / PGSIZE, 1);
  return -1;
}
```
简单总结就是先不要分配内存，保证父进程和子进程来映射同一片物理内存，并且在两者中都将pte的权限改为只读，并且用一个标志位（PTE_COW宏和PTE_V宏类似）来表示该页内存为COW内存（方便后续处理）

2. COW会导致进程或内核在访问COW内存页的时候发生page fault错误，在usertrap中需要识别该错误，并对其进行处理：
```c
void
usertrap(void)
{
...
     else if (r_scause() == 15 || r_scause() == 13) {
      // cow page fault handler
      uint64 va = r_stval();
      if (cow_copy(p->pagetable, va) == 0)
      {
        p->killed = 1;
      }
      // va = PGROUNDDOWN(va);
      // uint64 pa = walkaddr(p->pagetable, va);
      // pte_t *pte = walk(p->pagetable, va, 0);
      //
      // if (get_mem_ref(pa) == 1)
      // {
      //   // 如果某个进程访问页面，此时还是发生缺页中断，则只需要更改标志位即可
      //   // 此时意味着没有进程与其共享
      //   *pte &= (~PTE_COW);
      //   *pte |= (PTE_W);
      // } else {
      //   // allocate new memory
      //   char* npa = kalloc();
      //   // *pte = (*pte) & (~PTE_V);
      //   uint flags = (PTE_FLAGS(*pte) | PTE_W) & (~PTE_COW);
      //
      //   if (npa == 0 || pa == 0)
      //   {
      //     p->killed = 1;
      //   }
      //   // defer allocating and copying at here
      //   memmove(npa, (char *)pa, PGSIZE);
      //   // unmap the old page
      //   uvmunmap(p->pagetable, PGROUNDDOWN(va), 1, 1);
      //   if (mappages(p->pagetable, va, PGSIZE, (uint64)npa, flags) != 0){
      //     kfree(npa);
      //     p->killed = 1;
      //   }
      //   // decrease the count
      //   kfree((char*)PGROUNDDOWN(pa));
      // }
    }
...
}
```
注释的是自己手撸的版本，可惜在赋值标志位的时候人赋值晕了，后面感觉既然在copyout要用那的确应该搞个函数来封装一下，但有点懒就偷了一个老哥的，不过换汤不换药。主要思想就是如果是只有一个引用计数的内存页，那就恢复写权限并取消COW标志位，否则就分配新内存，并取消原有映射，建立新映射，同时减少内存页的引用计数

3. 在内核中也可能访问物理内存，此时也需要在copyout中处理
```c
int
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
{
    ...
    if (cow_check(pagetable, va0) != 0)
    {
      // pa0 must be returned
      pa0 = cow_copy(pagetable, va0);
    }
    if(pa0 == 0)
      return -1;
    ...
}
```
4. 引用计数，通过构造自旋锁，给每个可分配的内存页都在操作系统中搞了个锁，这个步骤还是比较繁琐的（参考别人的，有一定修改）

* 首先是定义锁
```c
struct mem_ref
{
    struct spinlock lock;
    int cnt;
};

struct mem_ref mem_ref[PHYSTOP/PGSIZE];
```
* 随后写一个辅助函数，在线程安全的情况下获取锁
```c
int
get_mem_ref(uint64 pa)
{
  acquire(&(mem_ref[pa/PGSIZE].lock));
  int res = mem_ref[(uint64)pa/PGSIZE].cnt;
  release(&(mem_ref[pa/PGSIZE].lock));
  return res;
}
```
* 在kinit中初始化锁
```c
void
kinit()
{
  for(int i = 0; i < PHYSTOP/PGSIZE; ++i)
  {
    // initialize the lock
    initlock(&(mem_ref[i].lock), "kmem_ref");
  }
  initlock(&kmem.lock, "kmem");
  freerange(end, (void*)PHYSTOP);
}
```
* 在freerange中对引用计数进行赋值
```c
void
freerange(void *pa_start, void *pa_end)
{
  char *p;
  p = (char*)PGROUNDUP((uint64)pa_start);
  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
  {
    // initialize the count
    mem_ref[(uint64)p/PGSIZE].cnt = 1;
    kfree(p);
  }
}
```
* 当且仅当引用计数为0时才可以在kfree中释放内存
```c
void
kfree(void *pa)
{
   ...
   // only free pa when memory reference is 0
    uint64 pa_idx = (uint64)pa / PGSIZE;
    acquire(&(mem_ref[pa_idx].lock));
    
    mem_ref[pa_idx].cnt--;
    if (mem_ref[pa_idx].cnt > 0)
    {
      release(&(mem_ref[pa_idx].lock));
      return;
    }
    release(&(mem_ref[pa_idx].lock));
   ... 
}
```

* 在分配内存页的时候需要给引用计数赋值为1（因为此时分配的内存之前被使用过后现在值为0，不符合实际意义）
```c
void *
kalloc(void)
{
    ...
    if(r)
    {
      uint64 pa_idx = (uint64)r / PGSIZE;
      acquire(&(mem_ref[pa_idx].lock));
      mem_ref[pa_idx].cnt = 1;
      release(&(mem_ref[pa_idx].lock));
    
      kmem.freelist = r->next;
    }
    ...
}
```
5. 将cow的处理过程写成一个函数，思路就是分配、取消映射再映射，偷懒偷了别人的函数了
```c
uint64
cow_copy(pagetable_t pagetable, uint64 va)
{

  va = PGROUNDDOWN(va);
  pte_t *pte = walk(pagetable, va, 0);
  uint64 pa = PTE2PA(*pte);

  if(get_mem_ref(pa) == 1)
  {
    *pte = (*pte) & (~PTE_COW);
    *pte = (*pte) | (PTE_W);
    return pa;
  }
  else
  {
    char *mem = kalloc();
    if(mem == 0){
      return 0;
    }

    memmove(mem, (char *)pa, PGSIZE);
    *pte = (*pte) & (~PTE_V);
    uint64 flag = PTE_FLAGS(*pte);
    flag = flag | PTE_W;
    flag = flag & (~PTE_COW);

    if(mappages(pagetable, va, PGSIZE, (uint64)mem, flag) != 0)
    {
      kfree(mem);
      return 0;
    }
    // decrease it!
    kfree((char*)PGROUNDDOWN(pa));

    return (uint64)mem;
  }
}
```

6. 另外一个辅助的函数本质上很简单，但由于复制的时候手贱把一些失败处理的删了导致测试通不过，抓耳挠腮半天才搞好，还得是测试啊妈的
```c
int
cow_check(pagetable_t pagetable, uint64 va)
{
  if(va > MAXVA)
    return 0;

  pte_t *pte = walk(pagetable, va, 0);
  if(pte == 0)
  {
    printf("fuck");// 这个是发现usertests会测试pte为0的边界情况，妈的！
    return 0;
  }
  if(((*pte) & (PTE_V)) == 0)
    return 0;
  int res = (*pte) & (PTE_COW);
  return res;
}
```
总结：
1. 重复两次的逻辑尽量给他函数封装
2. 一个函数太长了也要切割（其实最好是在写之前切割）
3. 异常处理是非常必要的，在比较边界的情况下会导致出错，虽然可能功能基本实现了，但不够鲁棒！
4. gdb的调试不仅需要对程序足够了解，还得好好学工具的使用啊，gdb能帮很大的忙
5. COW的逻辑不难，主要难的是对边界情况的处理，这个实验其实最好和lazy allocation一起做
6. 还是得研究一下测试程序，如何验证程序没有错误也是非常重要的
7. 虽然自己写了一点，但代码能跑要感谢[这个老哥](https://zhuanlan.zhihu.com/p/429821940)

# 7. Lab7
## 7.1 Uthread
该实验目的就是添加一个用户级的thread（不支持真正的并发），栈和寄存器由thread自己保存，感觉更像`协程`，看懂xv6实现底层的话还是比较简单的：
1. 从内核中扒一下context结构体，塞thread结构体里，很类似proc结构体的操作:
```c
struct context {
    uint64 ra;
    uint64 sp;

    // callee-saved
    uint64 s0;
    uint64 s1;
    uint64 s2;
    uint64 s3;
    uint64 s4;
    uint64 s5;
    uint64 s6;
    uint64 s7;
    uint64 s8;
    uint64 s9;
    uint64 s10;
    uint64 s11;
};

struct thread {
  char       stack[STACK_SIZE]; /* the thread's stack */
  int        state;             /* FREE, RUNNING, RUNNABLE */
  struct context context;
};
```
2. 那么创建线程应该做些什么呢？让该线程有正确的上下文，如果该线程要被执行了，让程序能够正确的执行，在此就是指定正确的sp寄存器和ra寄存器内容
```c
void 
thread_create(void (*func)())
{
  struct thread *t;

  for (t = all_thread; t < all_thread + MAX_THREAD; t++) {
    if (t->state == FREE) break;
  }
  // 找到了空闲线程后赋值为RUNNABLE
  t->state = RUNNABLE;
  // YOUR CODE HERE
  // 在sp寄存器中存储正确的栈指针位置（栈顶到栈底）
  t->context.sp = (uint64)t->stack + STACK_SIZE - 1;
  t->context.ra = (uint64)func;
}
```
3. thread_switch.S，这个没啥好说的，直接扒内核代码
```c
thread_switch:
    sd ra, 0(a0)
    sd sp, 8(a0)
    sd s0, 16(a0)
    sd s1, 24(a0)
    sd s2, 32(a0)
    sd s3, 40(a0)
    sd s4, 48(a0)
    sd s5, 56(a0)
    sd s6, 64(a0)
    sd s7, 72(a0)
    sd s8, 80(a0)
    sd s9, 88(a0)
    sd s10, 96(a0)
    sd s11, 104(a0)

    ld ra, 0(a1)
    ld sp, 8(a1)
    ld s0, 16(a1)
    ld s1, 24(a1)
    ld s2, 32(a1)
    ld s3, 40(a1)
    ld s4, 48(a1)
    ld s5, 56(a1)
    ld s6, 64(a1)
    ld s7, 72(a1)
    ld s8, 80(a1)
    ld s9, 88(a1)
    ld s10, 96(a1)
    ld s11, 104(a1)
    ret    /* return to ra */
```
4. thread_schedule，这个也没啥好说的，直接加上3中的函数即可（位置都指定了）
```c
thread_switch((uint64)&t->context, (uint64)&current_thread->context);
```
小结：主要是理解概念，这个实验设计得很好，准确理解了xv6如何完成切换的话只需要少量的代码即可完成功能，非常不错的实验！

## 7.2 Using threads
解决的核心问题：两个线程同时访问资源，应该如何保证线程安全？如果线程安全做到了，又如何保证性能？
1. 保证线程安全
朴素的思想就是加锁，pthread库提供了互斥锁，使用方式如下：
```c
pthread_mutex_t lock;            // declare a lock
pthread_mutex_init(&lock, NULL); // initialize the lock
pthread_mutex_lock(&lock);       // acquire lock
pthread_mutex_unlock(&lock);     // release lock
```
只需要在get和put函数加锁即可解决：
```c
pthread_mutex_t lock;

static struct entry *
get(int key)
{
  // hash操作，拼接靠链表
  int i = key % NBUCKET;

  struct entry *e = 0;

  pthread_mutex_lock(&lock);
  for (e = table[i]; e != 0; e = e->next)
  {
    if (e->key == key)
      break;
  }
  pthread_mutex_unlock(&lock);

  return e;
}

static void put(int key, int value)
{
  int i = key % NBUCKET;
  // is the key already present?
  struct entry *e = 0;
  pthread_mutex_lock(&lock);
  for (e = table[i]; e != 0; e = e->next)
  {
    if (e->key == key)
      break;
  }
  if (e)
  {
    // update the existing key.
    e->value = value;
  }
  else
  {
    // the new is new.
    insert(key, value, &table[i], table[i]);
  }
  pthread_mutex_unlock(&lock);
}
```

要记得完成锁的初始化，但以上的大锁又会带来新的问题，即难以使用CPU的性能，现在几乎是同步执行了，没有什么意义，因此引入了以下问题。

2. 如何在保证线程安全的情况下榨干CPU多核性能
这里很自然的思想是提供细粒度的锁，例如初始化多个锁，根据访问的key放到合适的位置，或者，对每一个节点都加单独的锁（很麻烦懒得做了hhh）。于是可以根据NBUCKET的数量（理解一下哈希表）来上锁：
```c
pthread_mutex_t lock[NBUCKET];

static struct entry *
get(int key)
{
  // hash操作，拼接靠链表
  int i = key % NBUCKET;

  struct entry *e = 0;

  pthread_mutex_lock(&lock[i]);
  for (e = table[i]; e != 0; e = e->next)
  {
    if (e->key == key)
      break;
  }
  pthread_mutex_unlock(&lock[i]);

  return e;
}

static void put(int key, int value)
{
  int i = key % NBUCKET;
  // is the key already present?
  struct entry *e = 0;
  // 根据i值决定哪把锁
  pthread_mutex_lock(&lock[i]);
  for (e = table[i]; e != 0; e = e->next)
  {
    if (e->key == key)
      break;
  }
  if (e)
  {
    // update the existing key.
    e->value = value;
  }
  else
  {
    // the new is new.
    insert(key, value, &table[i], table[i]);
  }
  pthread_mutex_unlock(&lock[i]);
}

int main(int argc, char *argv[]) 
{
   ...
  // 互斥锁初始化
  for (int i = 0; i < NBUCKET; i++)
  {
    pthread_mutex_init(&lock[i], NULL);
  }
  ...
}
```
其实上面的实现还有些问题，如果线程只是读的话，没必要加锁，让其读好了，因此可以把get中的锁删了，性能可以再一次提升：
![threadConcurrent](/img/6.S081/threadConcurrent.png "concurrent thread")
其实到这里还是有很多问题：
1. 互斥锁是什么，和自旋锁睡眠锁有什么不同，条件变量和信号量又是什么？

参考[这个](https://www.zhihu.com/question/66733477)

2. pthread提供了哪些接口，含义又是什么？

TODO

## 7.3 Barrier
介绍了条件变量相关知识，利用pthread提供的条件变量机制，让所有线程都能执行完一轮后再进入下一次循环，理解条件变量即可，很类似sleep锁
```c
static void
barrier()
{
  // YOUR CODE HERE
  //
  // Block until all threads have called barrier() and
  // then increment bstate.round.
  //
  pthread_mutex_lock(&bstate.barrier_mutex);
  // 记录有多少个线程到达此处
  bstate.nthread++;
  // 一旦线程到达数量等于总数量，则进入下一轮
  // 否则睡眠并等待
  if (bstate.nthread == nthread)
  {
    bstate.nthread = 0;
    bstate.round++;
    pthread_cond_broadcast(&bstate.barrier_cond);
  }
  else
  {
    // 释放锁
    pthread_cond_wait(&bstate.barrier_cond, &bstate.barrier_mutex);
  }
  pthread_mutex_unlock(&bstate.barrier_mutex);
}
```
核心思想是计算到达的线程有多少个，早到的就等一等，最后一个到的来完成唤醒其他线程的任务
小结：其实第一个实验还好，后面俩实验完全是pthread教程了，不写感觉也问题不大。
# 8. Lab8
## 8.1 Memory allocator
问题来源于在分配或释放内存时，内核总是一把大锁保平安，实际上这样在多核情况下的性能并不好，那么一个有趣的思路是既然CPU们争抢一把锁，不如给每个CPU一份free list用于管理内存，同时给每个free list一把锁，来减少资源竞争，同时要完成的任务是当一个CPU的free list没空闲内存之后，要去其他CPU那里偷点过来。
那这里就会有两个基本的思路：
1. 在初始化的时候计算空闲内存页的数量以及CPU数量，均分一下好了（后面发现其实这种想法还是得依赖于偷）
2. 只给第一个CPU，让其他CPU要内存的时候自己去偷

这里用第二种思路好了，正好可以妙用一手偷男机制

基本的想法是在freepage（其实是kfree）的时候获取cpu id，把所有内存都给这个运行freepage的cpu（记得关中断），这时候基本的问题就来了，需要初始化一个和CPU数量相同的数组，并且需要初始化这些lock：
```c
struct {
  struct spinlock lock;
  struct run *freelist;
} kmem[NCPU]; // 根据cpu数量初始化数组

void
kinit()
{
  // for 初始化所有cpu内存锁
  for (int i = 0; i < NCPU; i++) {
    // 这里第二个就算了，懒得改了
    initlock(&kmem[i].lock, "kmem");
  }
  // initlock(&kmem.lock, "kmem");
  freerange(end, (void*)PHYSTOP);
}

void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("kfree");

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  r = (struct run*)pa;

  push_off();
  // 获取cpuid
  int id = cpuid();
  // 根据cpuid获取锁
  // 感觉没有必要获取锁了这里，又没有并发问题
  // 妈的不对，仔细想想steal的时候会有并发问题。。
  acquire(&kmem[id].lock);
  r->next = kmem[id].freelist;
  kmem[id].freelist = r;
  release(&kmem[id].lock);
  pop_off();
}

void *
kalloc(void)
{
  struct run *r;
  // 这里需要思考一下，kfree一定能snyx

  push_off();
  int id = cpuid();


  acquire(&kmem[id].lock);
  r = kmem[id].freelist;
  if(r)
    kmem[id].freelist = r->next;
  else {
    // 如果r已经空了就会很坏很坏
    // 只能偷点
    for(int i = 0; i < NCPU; i++) {
      // 不要重复去搞
      if(id == i) continue;
      acquire(&kmem[i].lock);
      if (kmem[i].freelist) {
        // 如果别人的有货，就偷一片过来
        r = kmem[i].freelist;
        kmem[i].freelist = kmem[i].freelist->next;
        release(&kmem[i].lock);
        break;
      }
      release(&kmem[i].lock);
    }
  }
  release(&kmem[id].lock);
  pop_off();


  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}
```
## 8.2 Buffer cache
在现代 OS 中，所有 I/O 操作都不会直接与 disk 打交道，一般都是将 disk 中的数据拷贝到 memory 中，进程再从 memory 中进行读写。memory 中用来暂存 disk 数据的地方，叫做 Buffer cache
多个进程同时使用文件系统时，会对一把大锁（bcache.lock）产生竞争，任务就是减少对这把锁的竞争，基本思路都是把锁改小，比如让每个小的缓存都有一个锁，要求修改bget和brelse来减少对bcache.lock的竞争
按照提示看来是要用hash表了，blockno来作为key，根据提示有以下几点需要注意：
- 可以用固定数量的hash表，只要能够映射就OK
- 在hash表内搜索或增加条目必须是原子的
- 之前用的双向链表的形式必须要删（看来得大改妈的），并且使用时间标记（ticks）来看看谁是最不常用的buffer，且引用计数为0，且没必要在brelse中获取bcache lock（这句没搞懂为什么）

{{< notice notice-tip >}}
这道题目要搞清楚每一个锁是用来保护哪些数据的，保持一致，锁保护的数据要不同
{{< /notice >}}

其实问题也是非常清晰的：bcache.lock这个锁太大了，为了减少竞争只能减少锁的大小，因此这里采用上一章的一个很有意思的主题，哈希表，每个哈希表又对应一条双向链表，来保存buffer。

1. 修改bcache结构体，采用和上一章中相同的方式保存数据
```c
#define NBUCKET 13

struct
{
  // struct spinlock lock; // 一把大锁保平安
  struct buf buf[NBUF];
  struct buf buckets[NBUCKET];
  struct spinlock locks[NBUCKET];

  // Linked list of all buffers, through prev/next.
  // Sorted by how recently the buffer was used.
  // head.next is most recent, head.prev is least.
  // struct buf head;
} bcache;
```
locks保护对应的buckets

2. 修改binit来给锁进行初始化，并且把所有buf都挂载到buckets[0]上，让其他bucket来偷
```c
void binit(void)
{
  struct buf *b;

  // initlock(&bcache.lock, "bcache");
  for (int i = 0; i < NBUCKET; i++)
  {
    initlock(&bcache.locks[i], "bcache");
    // 先自指之后可以偷男来偷一手
    bcache.buckets[i].prev = &bcache.buckets[i];
    bcache.buckets[i].next = &bcache.buckets[i];
  }

  for (b = bcache.buf; b < bcache.buf + NBUF; b++)
  {
    // 这里是借用了原有的方法，不过先都挂在第一个bucket上
    // 之后偷一偷分配出去
    b->next = bcache.buckets[0].next;
    b->prev = &bcache.buckets[0];
    initsleeplock(&b->lock, "buffer");
    bcache.buckets[0].next->prev = b;
    bcache.buckets[0].next = b;
  }
}
```
3. 先改brelse，这个函数的作用是释放这个block buffer的使用权，并减少其引用计数，若引用计数为0记录一下使用时间，用trap中的ticks即可
```c
void brelse(struct buf *b)
{
  if (!holdingsleep(&b->lock))
    panic("brelse");

  releasesleep(&b->lock);

  // 这里就hash了一手，取模也是hash
  acquire(&bcache.locks[b->blockno % NBUCKET]);
  b->refcnt--;
  if (b->refcnt == 0)
  {
    b->time = ticks;    // 这个time是在buf.h中加的
  }
  release(&bcache.locks[b->blockno % NBUCKET]);
}
```
这里可以停一下想想为什么需要睡眠锁，如果多个进程都访问同一块block的buffer的话，他们的确可以找到这个buffer，但很有可能这个buffer被其他进程在用了，此时只能等待，但万万不能自旋，鬼知道别人要用多久，毕竟释放权在别人手上，只能先睡眠了。当别人使用完毕，那就调用brelse，来唤醒这些睡眠的进程，并且别人使用完了后把引用计数减1

4. bpin和bunpin

这个思路就很简单，直接hash一手就ok
```c
void bpin(struct buf *b)
{
  acquire(&bcache.locks[b->blockno % NBUCKET]);
  b->refcnt++;
  release(&bcache.locks[b->blockno % NBUCKET]);
}

void bunpin(struct buf *b)
{
  acquire(&bcache.locks[b->blockno % NBUCKET]);
  b->refcnt--;
  release(&bcache.locks[b->blockno % NBUCKET]);
}
```

5. bget是最麻烦的，基本思路和上一道的kalloc是相同的，先自己找，不够就向别人那里偷
```c
static struct buf *
bget(uint dev, uint blockno)
{
  struct buf *b;

  int key = blockno % NBUCKET;

  acquire(&bcache.locks[key]);
  // 找找这个block是不是已经被缓存了
  for (b = bcache.buckets[key].next; b != &bcache.buckets[key]; b = b->next)
  {
    if (b->dev == dev && b->blockno == blockno)
    {
      b->refcnt++;
      release(&bcache.locks[key]);
      // 这里不能简单地用自旋锁，否则会导致自旋过久，睡眠锁比较好
      // 其他进程用完这个内存块之后，就会调用brelse，其中会wakeup这些睡眠者
      // 谁先第一个谁就可以返回
      acquiresleep(&b->lock);
      return b;
    }
  }

  // 到这里的时候说明这个block没有被缓存，这个时候得先分配一个buffer给他
  uint minticks = ticks;
  struct buf *victim = 0;

  // 双向链表，回到原点说明遍历完毕
  for (b = bcache.buckets[key].next; b != &bcache.buckets[key]; b = b->next)
  {
    if (b->refcnt == 0 && b->time <= minticks)
    {
      minticks = b->time;
      victim = b;
      // 这里不返回的原因是会找不到真正最小的
    }
  }
  // 此时还需要判断是否找到了这样一个空闲的且是LRU的buffer
  if (victim)
  {
    // 找到了就正常覆盖整个victim
    // 标记这个buffer是属于哪个block的
    victim->dev = dev;
    victim->blockno = blockno;
    victim->valid = 0;  // 表明之前的数据是无效的
    victim->refcnt = 1; // 有一个引用计数
    release(&bcache.locks[key]);
    // 这个buffer可以直接使用
    // 但为了和之后的brelse中的release搭配还是使用sleep
    acquiresleep(&victim->lock);
    return victim;
  }
  else
  {
    // 说明这个bucket里没有空buffer了，只能从别的bucket里偷
    for (int i = 0; i < NBUCKET; i++)
    {
      if (i == key)
        continue;
      acquire(&bcache.locks[i]);
      minticks = ticks;
      // 找出别的bucket里LRU的那个buffer，给他偷过来
      for (b = bcache.buckets[i].next; b != &bcache.buckets[i]; b = b->next)
      {
        if (b->refcnt == 0 && b->time <= minticks)
        {
          minticks = b->time;
          victim = b;
        }
      }
      // 判断找没找到，找到继续，没找到就跳下一个bucket继续
      if (!victim)
      {
        release(&bcache.locks[i]);
        continue;
      }
      // 找到了之后就正常初始化先
      victim->dev = dev;
      victim->blockno = blockno;
      victim->valid = 0;  // 表明之前的数据是无效的
      victim->refcnt = 1; // 有一个引用计数

      // 下面逻辑比较绕，画个图就很好理解
      // 从这个bucket里取出来放到自己的bucket里
      victim->next->prev = victim->prev;
      victim->prev->next = victim->next;
      release(&bcache.locks[i]);

      victim->next = bcache.buckets[key].next;
      bcache.buckets[key].next->prev = victim;
      bcache.buckets[key].next = victim;
      victim->prev = &bcache.buckets[key];
      release(&bcache.locks[key]);
      acquiresleep(&victim->lock);
      return victim;
    }
  }

  // 如果上述过程都不能获取一个正确的buffer那就报错
  panic("bget: no buffers");
}
```
bget的任务是首先看这个buffer是不是被缓存了，如果是的话就直接返回，不是就创建新buffer，如果自己bucket中没有了，那就去别人的bucket中偷，偷的过程比较麻烦，毕竟有双向链表的操作，当然返回之前记得初始化。
{{< notice notice-tip >}}
更要记住哪些锁是用来保护哪些数据的：比如这里自己造的locks其实是保护这些buffer中除了data以外的数据，而buffer自己的lock是用来保护data的，保证只有一个人修改！
在使用过程中，如果获取了自己造的locks，那就只能改除了data以外的数据，而想改data只能获取buffer自己的lock，一定要一致，保证并发程序的正确性！
{{< /notice >}}
小结：总体来说这俩实验思路很相似，特别是有了lab7中已经有的hash操作之后很容易想到这些，不过实现过程中还是写G了，参考了一下[这个老哥的](https://zhuanlan.zhihu.com/p/609771386)，写的很不错。要减少并发中的竞争性只能依赖于减小锁的粒度！同时这一个实验很重要的是学会锁保护的对象是谁，要修改保护的对象必须要获取对应的锁。总结来说还是一句话，要依赖别人的经验，也要有自己的思考！
# 9. Lab9
## 9.1 Large files
目前fs只支持256+12个blocks，一个block 1kb，因此支持的文件比较小，因此该实验要求修改模块以支持更大的文件，实验要求都描述清楚了，需要实现二层链接即其中某个direct address要改成doubly indirect address。这个倒也没多难，无非是前11个用作直接块，第12个用作一重间接块，第13个用作二重间接块
1. 修改NDIRECT等定义，修改inode和dinode定义，增加一些定义
```c
#define NDIRECT 11
#define NINDIRECT (BSIZE / sizeof(uint))
#define NDUBINDIRECT (256 * NINDIRECT)
#define MAXFILE (NDIRECT + NINDIRECT + NDUBINDIRECT)

// On-disk inode structure
struct dinode {
    short type;              // File type
    short major;             // Major device number (T_DEVICE only)
    short minor;             // Minor device number (T_DEVICE only)
    short nlink;             // Number of links to inode in file system
    uint size;               // Size of file (bytes)
    uint addrs[NDIRECT + 2]; // Data block addresses
};

// in-memory copy of an inode
// 和block buffer一样的缓存机制
struct inode {
    uint dev;  // Device number
    uint inum; // Inode number
    int ref;   // Reference
             // count，这里是内存中的引用计数，即在内存中引用此文件的指针数量，如果ref=0，则将其在内存中释放（写回到磁盘上）
    struct sleeplock lock; // protects everything below here
    int valid;             // inode has been read from disk?

    short type; // copy of disk inode
    short major;
    short minor;
    short nlink; // 统计有多少文件目录引用到此inode以确定什么时候释放（硬盘上释放）
    uint size;   // 统计文件大小
    uint addrs[NDIRECT + 2]; // 这个数组记录data blocks的number，毕竟inode大小是相同的
};
```
2. 修改bmap函数，使其支持两级块的索引，这里需要注意的是一定要记得brelse，难度不大
```c
static uint bmap(struct inode* ip, uint bn) {
...

    bn -= NINDIRECT;

    if(bn < NDUBINDIRECT) {
        // 找到第一层indirect address
        if((addr = ip->addrs[NDIRECT + 1]) == 0)
            ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
        // 读取第一层数据
        bp = bread(ip->dev, addr);
        a = (uint*) bp->data;
        if((addr = a[bn / 256]) == 0) {
            a[bn / 256] = addr = balloc(ip->dev);
            log_write(bp);
        }
        brelse(bp);
        // 至此是最后一层
        bp = bread(ip->dev, addr);
        a = (uint*) bp->data;
        if((addr = a[bn % 256]) == 0) {
            a[bn % 256] = addr = balloc(ip->dev);
            log_write(bp);
        }
        brelse(bp);
        return addr;
    }

    panic("bmap: out of range");
}
```

3. 确保itrunc释放的时候也释放了
```c
void itrunc(struct inode* ip) {
...
    if(ip->addrs[NDIRECT + 1]) {
        bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
        a = (uint*) bp->data;
        for(j = 0; j < NINDIRECT; j++) {
            if(a[j]) {
                for(k = 0; k < NINDIRECT; k++) {
                    struct buf* bp2 = bread(ip->dev, a[j]);
                    uint* a2 = (uint*) bp2->data;
                    if(a2[k]) {
                        bfree(ip->dev, a2[k]);
                    }
                    brelse(bp2);
                }
                bfree(ip->dev, a[j]);
            }
        }
        brelse(bp);
        bfree(ip->dev, ip->addrs[NDIRECT + 1]);
        ip->addrs[NDIRECT + 1] = 0;
    }

    ip->size = 0;
    iupdate(ip);
}
```
4. 这个实验不难，仿照一级块套一层循环即可
## 9.2 Symbolic links
xv6原生支持的是硬链接，即不同名的文件却有相同的inode，而这里要支持的是软链接，即文件中保存的真正文件的path。
1. 增加symlink系统调用，老套路了，这里不写
2. 增加宏定义
```c
#define T_SYMLINK 4 // 软链接
#define O_NOFOLLOW 0x100
```
3. 在makefile中增加symlinktest
4. 实现sys_symlink系统调用，这里主要思路是创建新文件，里面内容是链接的真正文件地址，`使用其他函数的时候必须注意返回的inode是否带锁，否则很容易死锁，一定要注意！`
```c
uint64 sys_symlink(void) {
    // input: target & path
    char target[MAXPATH], path[MAXPATH];

    if(argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0)
        return -1;

    begin_op();

    struct inode* ip;
    // 搞一个inode，类型是符号链接
    // 内容则是真正链接的文件的路径，在此处即是target
    // 在指定目录位置创建文件并返回inode，这里直接使用create函数，方便
    // 注意，这里返回的ip是带锁的
    if((ip = create(path, T_SYMLINK, 0, 0)) == 0) {
        end_op();
        return -1;
    }
    // 把真实文件path写入到此inode中
    int res = writei(ip, 0, (uint64) target, 0, MAXPATH);

    if(res != MAXPATH) {
        end_op();
        return -1;
    }

    iunlockput(ip);

    end_op();
    return 0;
}
```
5. open的时候也需要处理符号链接的情况，符号链接很容易成环，需要判断成环的情况！（注意锁的获取和释放，不要死锁！）
```c
uint64 sys_open(void) {
    char path[MAXPATH];
    int fd, omode;
    struct file* f;
    struct inode* ip;
    int n;
    int count = 0; // 计算寻找次数

    if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)
        return -1;

    begin_op();

    if(omode & O_CREATE) {
        ip = create(path, T_FILE, 0, 0);
        if(ip == 0) {
            end_op();
            return -1;
        }
    } else {
        while(1) {
            if((ip = namei(path)) == 0) {
                end_op();
                return -1;
            }
            ilock(ip);

            if(ip->type == T_SYMLINK && !(omode & O_NOFOLLOW)) {
                // 递归地打开该符号链接，这里套个循环得了
                if(count > 10) {
                    iunlockput(ip);
                    end_op();
                    return -1;
                }
                int res;
                res = readi(ip, 0, (uint64) path, 0, MAXPATH);
                if(res != MAXPATH) {
                    iunlockput(ip);
                    end_op();
                    return -1;
                }
                iunlockput(ip);
                count++;
            } else {
                break;
            }
        }

        if(ip->type == T_DIR && omode != O_RDONLY) {
            iunlockput(ip);
            end_op();
            return -1;
        }
    }

...
}
```
小结：这章的实验做起来感觉都有思路，被第二个实验的返回数据带不带锁坑了一把，感觉C++资源的生命周期什么的可能就是想解决这个问题。不过实话说这个还真设计的不错，对文件系统彻底了解了，回头再补一波jyy的讲解看看微软的文件系统
# 10. Lab10
mmap系统调用：
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
mmap主要有俩功能：
1. 在进程间传输数据
2. 将文件映射到内存中以减少传统的数据复制（磁盘-内存buffer-用户空间）

- 该实验只需要映射文件，假设addr为0，由内核决定真正的地址并返回，如果失败则返回0xffffffffffffffff；
- length来决定映射的大小，未必和文件大小相同；
- prot设置内存读写与执行的权限
- flags决定写的内容需不需要被写回文件
- fd是指定文件描述符
- offset假设为0

在该实验中只要求实现文件映射内存，猜测可能是先标记一下，之后访问就page fault然后一页页地从文件中读到内存映射部分（user space）而非buffer cache中

另一个需要实现的是munmap
```c
int munmap(void *addr, size_t length);
```
清理指定范围的map，有点free的意思了，如果有脏数据并且有正确的flags就回写到文件，并解除指定位置的映射。成功返回0，失败返回-1

也就是说这个实验是要添加这俩系统调用了。但还不是很懂mmap的作用，直接看了(这个人的)[https://zhuanlan.zhihu.com/p/458326109]。
传统的xv6系统调用需要经过以下几步：

read系统调用->usertrap内核处理->sys_read->fileread->readi，由readi把数据从硬盘搬到内核缓存再搬到用户空间。在此过程中每次的读写都需要read、write经历上述系统调用过程。mmap就直接把文件内容搬到了用户空间，可以直接操作，免得每次都要经过系统调用这几步。

1. 添加mmap和munmap系统调用，添加mmaptest到makfile，老操作了，这里不写
2. mmap把真正的加载推迟到了访问时，很类似lazy allocation、copy on write的操作，在实现之前需要想想，如果要在访问时再加载，则必须保存mmap的相关信息，在此处构造了一个结构体来保存这些信息：virtual memory area（vma），来保存虚拟内存分布相关信息

proc.h：
```c
#define VMASIZE 16
struct vma {
    int used;
    uint64 addr;
    int length;
    int prot;
    int flags;
    int fd;
    int offset;
    struct file *file;
};

// Per-process state
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)

  struct vma vma[VMASIZE];
};
```
这里vma数组的大小按照题目hints给16即可

3. mmap实现就很简单了，只需要记录这些信息按兵不动，找一个没被用过的vma位置来保存自己的数据
```c
uint64 sys_mmap(void) {
  uint64 error = 0xffffffffffffffff;

  uint64 addr;
  int length, prot, flags, fd, offset;
  struct file *file;  // 根据fd获取

  if (argaddr(0, &addr) || argint(1, &length) || argint(2, &prot) || argint(3, &flags) || argfd(4, &fd, &file) ||
          argint(5, &offset)) {
    return error;
  }

  // 这三种情况同时出现必错
  if (!file->writable && (prot & PROT_WRITE) && flags == MAP_SHARED) {
    return error;
  }

  length = PGROUNDUP(length);

  struct proc* p = myproc();
  // 剩余可用空间不足
  if ((p->sz + length) > MAXVA) {
    return error;
  }

  // 从进程PCB可用VMA中找个空位置插进去
  // 这里不直接分配
  for (int i = 0; i < VMASIZE; i++) {
    if (p->vma[i].used == 0) {
      p->vma[i].used = 1;
      p->vma[i].addr = p->sz; // 不管给的地址是什么，都从现有位置开始增长
      p->vma[i].length = length;
      p->vma[i].prot = prot;
      p->vma[i].flags = flags;
      p->vma[i].fd = fd;
      p->vma[i].file = file;
      p->vma[i].offset = offset;
      // pin一下这个file
      filedup(file);
      p->sz += length;
      return p->vma[i].addr;
    }
  }
  return error;
}
```

4. 同时munmap也有思路，无非是unmap一部分或整体，找到对应的vma对其addr增加即可
```c
uint64 sys_munmap(void) {
  uint64 addr;
  int length;

  struct proc *p = myproc();
  struct vma *vma = 0;

  if (argaddr(0, &addr) || argint(1, &length)) {
    return -1;
  }
  addr = PGROUNDDOWN(addr);
  length = PGROUNDUP(length);

  // 找到对应的vma
  for (int i = 0; i < VMASIZE; i++) {
    if (addr >= p->vma[i].addr || addr < (p->vma[i].addr + p->vma[i].length)) {
      vma = &p->vma[i];
      break;
    }
  }
  if (vma == 0) return -1;
  // 这里很有趣，并没有全部都给删了，而是只删了申请的部分
  if (vma->addr == addr) {
    vma->addr += length;
    vma->length -= length;
    if (vma->flags & MAP_SHARED)
      filewrite(vma->file, addr, length);
    uvmunmap(p->pagetable, addr, length / PGSIZE, 1);
    if (vma->length == 0) {
      fileclose(vma->file);
      vma->used = 0;
    }
  }
  return 0;
}
```

5. 接下来就类似lazy allocation，cow等步骤了，在usertrap中增加page fault处理逻辑，主要思路就是根据发生错误的地址，找到对应vma，进而分配内存，从文件中读取数据并复制到新内存，mappages时给正确的标志位：
```c
void
usertrap(void)
{
...
  } else if((which_dev = devintr()) != 0){
    // ok
  } else if(r_scause() == 13 || r_scause() == 15) {
    uint64 va = r_stval();  // 发生page fault的位置

    if (va >= p->sz || va > MAXVA || PGROUNDUP(va) == PGROUNDDOWN(p->trapframe->sp)) {
      p->killed = 1;
    } else {
      // 正常的处理步骤
      struct vma *vma = 0;
      for (int i = 0; i < VMASIZE; i++) {
        // 找到这个地址对应的vma，即找到file
        if (p->vma[i].used == 1 && va >= p->vma[i].addr && (va < p->vma[i].addr + p->vma[i].length)) {
          vma = &p->vma[i];
          break;
        }
      }

      if (vma) {
        // 地址的页面底部
        va = PGROUNDDOWN(va);

        uint64 offset = va - vma->addr;

        uint64 mem = (uint64)kalloc();
        if (mem == 0) {
          p->killed = 1;
        } else {
          memset((void *)mem, 0, PGSIZE);
          // 把数据从文件中读取出来，感觉很怪，不还是一样吗
          ilock(vma->file->ip);
          readi(vma->file->ip, 0, mem, offset, PGSIZE);
          iunlock(vma->file->ip);
          // 设置权限位
          int flag = PTE_U;
          if (vma->prot & PROT_READ) flag |= PTE_R;
          if (vma->prot & PROT_WRITE) flag |= PTE_W;
          if (vma->prot & PROT_EXEC) flag |= PTE_X;

          if (mappages(p->pagetable, va, PGSIZE, mem, flag) != 0) {
            kfree((void *)mem);
            p->killed = 1;
          }
        }
      }

    }
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }
...
}
```

6. 与lazy allocation和cow类似，在uvmunmap和uvmcopy两个函数中删除panic，因为此时页面尚未被加载到page table，倒也不能直接panic
```c
void
uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
{
  uint64 a;
  pte_t *pte;

  if((va % PGSIZE) != 0)
    panic("uvmunmap: not aligned");

  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
    if((pte = walk(pagetable, a, 0)) == 0)
      panic("uvmunmap: walk");
    if((*pte & PTE_V) == 0)
      continue;
      // panic("uvmunmap: not mapped");
    if(PTE_FLAGS(*pte) == PTE_V)
      panic("uvmunmap: not a leaf");
    if(do_free){
      uint64 pa = PTE2PA(*pte);
      kfree((void*)pa);
    }
    *pte = 0;
  }
}

int
uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
{
  pte_t *pte;
  uint64 pa, i;
  uint flags;
  char *mem;

  for(i = 0; i < sz; i += PGSIZE){
    if((pte = walk(old, i, 0)) == 0)
      panic("uvmcopy: pte should exist");
    if((*pte & PTE_V) == 0)
      continue;
      // panic("uvmcopy: page not present");
    pa = PTE2PA(*pte);
    flags = PTE_FLAGS(*pte);
    if((mem = kalloc()) == 0)
      goto err;
    memmove(mem, (char*)pa, PGSIZE);
    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
      kfree(mem);
      goto err;
    }
  }
  return 0;

 err:
  uvmunmap(new, 0, i / PGSIZE, 1);
  return -1;
}
```

7. 在fork和exit系统调用部分也需要处理，fork的时候要复制vma数组，exit的时候要回写数据到文件（如果有标志位的话）
```c
int
fork(void)
{
...
  np->state = RUNNABLE;

  for(i = 0; i < VMASIZE; i++) {
    if(p->vma[i].used){
      memmove(&(np->vma[i]), &(p->vma[i]), sizeof(p->vma[i]));
      filedup(p->vma[i].file);
    }
  }

  release(&np->lock);

  return pid;
}

void
exit(int status)
{
  struct proc *p = myproc();

  if(p == initproc)
    panic("init exiting");

  // Close all open files.
  for(int fd = 0; fd < NOFILE; fd++){
    if(p->ofile[fd]){
      struct file *f = p->ofile[fd];
      fileclose(f);
      p->ofile[fd] = 0;
    }
  }

  for(int i = 0; i < VMASIZE; i++) {
    if(p->vma[i].used) {
      if(p->vma[i].flags & MAP_SHARED)
        filewrite(p->vma[i].file, p->vma[i].addr, p->vma[i].length);
      fileclose(p->vma[i].file);
      uvmunmap(p->pagetable, p->vma[i].addr, p->vma[i].length/PGSIZE, 1);
      p->vma[i].used = 0;
    }
  }
...
}
```
小结：之前mmap完全理解不了，这下感觉也是虚拟内存的妙用，虚拟化才是真正的神啊。这样一想，java调用dll的jna可能也是相同的操作，把库加载，然后俩进程执行，中间部分数据共享。头文件该加还是得加，不然会出错，如果可以的话可以用sh脚本来统一添加头文件和#pragma once。brk分配的内存只能等高位内存释放后才能释放，mmap分配的内存可以单独释放，当然释放是以页为单位。
# 11. Lab11
给e1000网卡加驱动，说实话本来以为是让人了解一下网络，没想到只是写个驱动，大概理解怎么写，但实在不想看这个datasheet了。

首先需要了解，网卡硬件收到数据后会通过DMA把数据放到内存指定位置，而发送也是通过到指定位置找数据发送，这些位置以及控制的指令都是通过读写内存映射的寄存器来做到的。以发送为例：
```c
struct mbuf {
  struct mbuf  *next; // the next mbuf in the chain
  char         *head; // the current start position of the buffer
  unsigned int len;   // the length of the buffer
  // 分配的页面是4kb，但这里只能用上mbuf大小的内存，2kb多一点，因此在此处head指向的就是buf中可用内存！
  char         buf[MBUF_SIZE]; // the backing store
};

// [E1000 3.2.3]
struct rx_desc
{
  // 存储接收数据的地址
  uint64 addr;       /* Address of the descriptor's data buffer */
  // 已经使用的长度
  uint16 length;     /* Length of data DMAed into data buffer */
  // 校验和
  uint16 csum;       /* Packet checksum */
  uint8 status;      /* Descriptor status */
  uint8 errors;      /* Descriptor Errors */
  uint16 special;
};


#define RX_RING_SIZE 16
// 循环数组用以存储真正要放数据的空间的地址
static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));
// 注意到上面需要一个空间，这里多半就是了
static struct mbuf *rx_mbufs[RX_RING_SIZE];
```

其中mbuf是真正存储数据的地方，rxdesc只不过是保存这些地址。根据hints和网上代码，这个lab的做法如下：
1. e1000_transmit
```c
int
e1000_transmit(struct mbuf *m)
{
  //
  // Your code here.
  //
  // the mbuf contains an ethernet frame; program it into
  // the TX descriptor ring so that the e1000 sends it. Stash
  // a pointer so that it can be freed after sending.
  //

  // 真正存数据的位置是mbuf，这里需要做的是把存了需要发送的数据的mbuf的地址放入空闲的发送位置里
  // 而运行完毕之后就需要释放该mbuf

  acquire(&e1000_lock);

  uint32 r_index = regs[E1000_TDT];

  // 检查是否满了
  if ((tx_ring[r_index].status & E1000_TXD_STAT_DD) == 0) {
    release(&e1000_lock);
    return -1;
  }

  // 已经发送的可以释放了
  if (tx_mbufs[r_index]) {
    mbuffree(tx_mbufs[r_index]);
  }

  // 原有的位置填上正确的需要传输的mbuf
  tx_ring[r_index].addr = (uint64) m->head;
  tx_ring[r_index].length = (uint64) m->len;
  tx_ring[r_index].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;

  tx_mbufs[r_index] = m;
  regs[E1000_TDT] = (regs[E1000_TDT] + 1) % TX_RING_SIZE;
  release(&e1000_lock);
  return 0;
}
```

2. e1000_recv
```c
static void
e1000_recv(void)
{
  //
  // Your code here.
  //
  // Check for packets that have arrived from the e1000
  // Create and deliver an mbuf for each packet (using net_rx()).
  //

  // 网卡会用DMA的方式把数据放到合适的位置
  // 之后产生中断，进入该函数，该函数主要负责采用net_rx处理mbuf的数据
  // 要记得分配新的mbuf，原来的mbuf应该是给net_rx使用了
  while (1) {
    // 获取下标
    uint32 r_index = (regs[E1000_RDT] + 1) % RX_RING_SIZE;

    if ((rx_ring[r_index].status & E1000_RXD_STAT_DD) == 0) {
      return;
    }
    rx_mbufs[r_index]->len = (uint32)rx_ring[r_index].length;
    if (rx_mbufs[r_index]) {
      // 此时该指针的负责人被转向net_rx，由其负责释放，同时也避免了复制
      net_rx(rx_mbufs[r_index]);
    }
    rx_mbufs[r_index] = mbufalloc(0);
    rx_ring[r_index].addr = (uint64)rx_mbufs[r_index]->head;
    rx_ring[r_index].status = 0;
    regs[E1000_RDT] = r_index;
  }
}
```
这个实验感觉出的一般，重点并非网络而是驱动的编写，重点我倒是掌握了，懒得去读驱动手册了
# 参考
1. [网友网站1](https://blog.miigon.net/posts/s081-ending/)
2. [csdiy的介绍](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)
3. 中文翻译
    1. [课本翻译](http://xv6.dgs.zone/)
    2. [课程中文翻译](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/)
4. 环境搭建、调试以及代码跳转
    1. [MIT 6.S081 2020 操作系统 实验环境搭配详解及问题处理](https://zhuanlan.zhihu.com/p/331492444)
    2. [Fall2020/6.S081-如何在 QEMU 中使用 gdb](https://zhuanlan.zhihu.com/p/342402097)
    3. [MIT 6.S081: Lab 0 搭建环境](https://zhuanlan.zhihu.com/p/343655412)
    4. [MIT 6.S081 xv6调试不完全指北 - KatyuMarisa - 博客园](https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html)
    5. [MIT 6S081 qemu-gdb debug调试新手指南!!!!](https://zhuanlan.zhihu.com/p/354794701)
    6. [从零开始使用Vscode调试XV6](https://zhuanlan.zhihu.com/p/501901665)
    7. [在vscode上完美调试xv6指南](https://zhuanlan.zhihu.com/p/567525198)
    8. [6.S081的调试和VSCode环境配置](https://zhangjk98.xyz/6.S081-VSCode-prepare-and-kernel-debugging/#VSCode%E9%85%8D%E7%BD%AE)
5. 课程官网以及视频
    1. [6.S081 / Fall 2020](https://pdos.csail.mit.edu/6.S081/2020/schedule.html)
    2. [Lecture 6 -  Isolation & System Call Entry_Exit 中文版_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1rS4y1n7y1/?p=5&vd_source=71ee144274d993f1c946fc98badf272d)
    3. [老外xv6代码详解](https://www.youtube.com/playlist?list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB)
    4. [代码导读中文视频](https://www.bilibili.com/video/BV1ou41127p9/?spm_id_from=333.788&vd_source=71ee144274d993f1c946fc98badf272d)
6. [阿苏EEer](https://tarplkpqsm.feishu.cn/docs/doccnBFsXFMsAr1oXEVsaT9E3Jg)，[也是这个UP主的，更正经一点](https://tarplkpqsm.feishu.cn/docs/doccnoBgv1TQlj4ZtVnP0hNRETd)
7. [cactus-agenda-c84.notion.site](https://cactus-agenda-c84.notion.site/XV6-labs-2021-0894f931b3324edea30dca7826c01a97)，对课本有详细的解释